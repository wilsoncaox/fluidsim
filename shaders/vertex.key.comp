
#version 450

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct ParticleData {
    vec4 position;
    vec4 velocity;
    vec4 predicted_position;
};

layout(std430, set = 0, binding = 0) buffer Read {
    ParticleData[] data;
} read;

layout(std430, set = 1, binding = 0) buffer Write {
    ParticleData[] data;
} write;

layout(std430, set = 2, binding = 2) buffer Scan1 {
    uint data[];
} scan1;


layout(std430, set = 3, binding = 2) buffer Scan2 {
    uint data[];
} scan2;


layout(std430, set = 4, binding = 2) buffer Scan3 {
    uint data[];
} scan3;


layout(std430, set = 5, binding = 2) buffer Scan4 {
    uint data[];
} scan4;

layout(push_constant) uniform PushConstants {
    uint particle_count;
    float smoothing_radius;
} pc;

const float smoothing_radius = 0.2;
const int HASH_K1 = 73856093;
const int HASH_K2 = 19349663;
const int HASH_K3 = 83492791;
const int table_cells = 17658;

int grid_from_pos(float value) {
    return int(floor(value / smoothing_radius));
}

uint get_key(vec4 position) {
    int grid_x = grid_from_pos(position.x);
    int grid_y = grid_from_pos(position.y);
    int grid_z = grid_from_pos(position.z);

    uint hash = (grid_x * HASH_K1) ^ (grid_y * HASH_K2) ^ (grid_z * HASH_K3);
    uint key = uint((hash % table_cells + table_cells) % table_cells);
    return key;
}

void main() {
    uint id = gl_GlobalInvocationID.x;   
    if (id >= pc.particle_count) {
        return;
    }
      
    ParticleData current = read.data[id];
    uint key = get_key(current.predicted_position);

    scan1.data[id] = key;
    scan2.data[id] = key;
    scan3.data[id] = key;
    scan4.data[id] = key;

    current.position.w = key;
    write.data[id] = current;
}
