
#version 450

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct ParticleData {
    vec4 position;
    vec4 velocity;
    vec4 predicted_position;
};

layout(std430, set = 0, binding = 0) buffer Read {
    ParticleData[] data;
} read;

layout(std430, set = 1, binding = 0) buffer Write {
    ParticleData[] data;
} write;

layout(std430, set = 2, binding = 2) buffer Scan1 {
    uint data[];
} scan1;


layout(std430, set = 3, binding = 2) buffer Scan2 {
    uint data[];
} scan2;


layout(std430, set = 4, binding = 2) buffer Scan3 {
    uint data[];
} scan3;


layout(std430, set = 5, binding = 2) buffer Scan4 {
    uint data[];
} scan4;

layout(push_constant) uniform PushConstants {
    uint particle_count;
    float smoothing_radius;
} pc;

const int hashK1 = 15823;
const int hashK2 = 9737333;
const int hashK3 = 9737357;


const float smoothing_radius = 0.25;

int key_from_hash(int hash) {
    int count = int(pc.particle_count);
    int k = hash % count;
    return k;
}

int grid_from_pos(float value) {
    return int(ceil((2*value - smoothing_radius) / (2 * smoothing_radius)));
}

int get_key(vec4 position) {
    int grid_x = grid_from_pos(position.x);
    int grid_y = grid_from_pos(position.y);
    int grid_z = grid_from_pos(position.z);

    int hash = grid_x * hashK1 + grid_y * hashK2 + grid_z*hashK3;
    int key = key_from_hash(abs(hash));
    return key;
}

void main() {
    uint id = gl_GlobalInvocationID.x;   
    if (id >= pc.particle_count) {
        return;
    }
      
    ParticleData current = read.data[id];
    int key = get_key(current.position);

    scan1.data[id] = key;
    scan2.data[id] = key;
    scan3.data[id] = key;
    scan4.data[id] = key;

    current.position.w = key;
    write.data[id] = current;
}
